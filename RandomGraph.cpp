// Orz AekdyCoin 福大核武景润后人

#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <cmath>
#include <cstdlib>
#include <iostream>
#include <sstream>
#include <functional>
#include <cctype>
#include <string>

using namespace std;

#define all(X) (X).begin(), (X).end() 
#define sz(a) int((a).size())

typedef long long ll;

class RandomGraph
{
public:
	double probability(int n, int p);
};

double dp[64][64][64];
double pos[64][64];

double gao(int e, int ne, double p)
{
    double ret = 1;
    while (e--) ret *= p;
    while (ne--) ret *= (1 - p);
    return ret;
}

double RandomGraph::probability(int n, int p)
{
    double pp = p / 1000.0;
    for (int e = 0; e <= n; ++e) {
        for (int ne = 0; ne + e <= n; ++ne) {
            pos[e][ne] = gao(e, ne, pp);
        }
    }
    memset(dp, 0, sizeof(dp));
    dp[1][0][0] = 1;
    for (int total = 1; total < n; ++total) {
        for (int one = 0; one <= total; ++one) {
            for (int two = 0; two * 2 + one <= total; ++two) {
                int left = total - one - two * 2;
                if (left % 3 == 0) {
                    int three = left / 3;
                    double base = dp[one][two][three];
                    
                    // 1. none
                    dp[one + 1][two][three] += base * pos[0][total];
                    
                    // 2. new + 1 = two
                    if (one) {
                        dp[one - 1][two + 1][three] += base * one * pos[1][total - 1];
                    }
                    
                    // 3. new + 1 + 1 = three
                    if (one >= 2) {
                        dp[one - 2][two][three + 1] += base * one * (one - 1) / 2.0 * pos[2][total - 2];
                    }
                    
                    // 4. new + 2 = three;
                    if (two) {
                        dp[one][two - 1][three + 1] += base * two * 2 * pos[1][total - 1];
                        dp[one][two - 1][three + 1] += base * two * pos[2][total - 2];
                    }
                }
            }
        }
    }
    double ret = 0;
    for (int one = 0; one <= n; ++one) {
        for (int two = 0; two * 2 + one <= n; ++two) {
            int left = n - one - two * 2;
            if (left % 3 == 0) {
                int three = left / 3;
                ret += dp[one][two][three];
            }
        }
    }
    return 1 - ret;
}

// BEGIN CUT HERE

/*
// PROBLEM STATEMENT
// Consider a random undirected graph on n vertices.
The vertices are numbered 0 through n-1.
For each i and j such that 0 <= i < j <= n-1, the graph contains the edge i-j with probability p/1000.
The probabilities that different edges are present in the graph are all mutually independent.



You are given the ints n and p.
Calculate and return the probability that the random graph generated using the above procedure contains at least one connected component with 4 or more vertices.

DEFINITION
Class:RandomGraph
Method:probability
Parameters:int, int
Returns:double
Method signature:double probability(int n, int p)


NOTES
-Your return value must have an absolute or relative error less than 1e-9.
-A connected component is a maximal set S of vertices such that you can get from any vertex in S to any other vertex in S by following a sequence of edges. For example, if a graph with n=5 contains edges 0-2, 2-4, and 1-3, its connected components are {0,2,4} and {1,3}.


CONSTRAINTS
-n will be between 2 and 50, inclusive.
-p will be between 0 and 1000, inclusive.


EXAMPLES

0)
7
0

Returns: 0.0

The probability of each edge is 0. Therefore, this graph will always have 7 isolated vertices = 7 connected components, each with just a single vertex.

1)
3
620

Returns: 0.0

This graph only has 3 vertices, so it is impossible to have a connected component with at least 4 vertices.

2)
4
500

Returns: 0.59375

There are 64 different graphs on 4 labeled vertices.
As p=500, each of these 64 graphs is equally likely to be generated by our procedure. 
A graph on 4 vertices has a connected component with 4 or more vertices if and only if the entire graph is connected.
Out of our 64 possible graphs, 38 are connected.
Therefore, the probability we are looking for is 38/64.

3)
8
100

Returns: 0.33566851611343496

In this case, some of the good graphs have two connected components, each with 4 vertices.

4)
15
50

Returns: 0.5686761670525845



5)
50
10

Returns: 0.7494276522159893



6)
50
1000

Returns: 1.0



*/

#define ARRSIZE(x) (sizeof(x)/sizeof(x[0]))

template<typename T>
void print(T a) {
	cerr << a;
}

void print(long long a) {
	cerr << a << "LL";
}

void print(string a) {
	cerr << '"' << a << '"';
}

template<typename T>
void print(vector<T> a) {
	cerr << "{";
	for (unsigned i = 0; i != a.size(); i++) {
		if (i != 0) cerr << ", ";
		print(a[i]);
	}
	cerr << "}" << endl;
}

template<typename T>
void eq(int n, T have, T need) {
	if (have == need) {
		cerr << "Case " << n << " passed." << endl;
	} else {
		cerr << "Case " << n << " failed: expected ";
		print(need);
		cerr << " received ";
		print(have);
		cerr << "." << endl;
	}
}

template<typename T>
void eq(int n, vector<T> have, vector<T> need) {
	if(have.size() != need.size()) {
		cerr << "Case " << n << " failed: returned " << have.size() << " elements; expected " << need.size() << " elements.";
		print(have);
		print(need);
		return;
	}
	for(unsigned i = 0; i < have.size(); i++) {
		if(have[i] != need[i]) {
			cerr << "Case " << n << " failed. Expected and returned array differ in position " << i << ".";
			print(have);
			print(need);
			return;
		}
	}
	cerr << "Case " << n << " passed." << endl;
}

void eq(int n, string have, string need) {
	if (have == need) {
		cerr << "Case " << n << " passed." << endl;
	} else {
		cerr << "Case " << n << " failed: expected ";
		print(need);
		cerr << " received ";
		print(have);
		cerr << "." << endl;
	}
}

int main() {
    {
        RandomGraph theObject;
        eq(0, theObject.probability(7, 0),0.0);
    }
    {
        RandomGraph theObject;
        eq(1, theObject.probability(3, 620),0.0);
    }
    {
        RandomGraph theObject;
        eq(2, theObject.probability(4, 500),0.59375);
    }
    {
        RandomGraph theObject;
        eq(3, theObject.probability(8, 100),0.33566851611343496);
    }
    {
        RandomGraph theObject;
        eq(4, theObject.probability(15, 50),0.5686761670525845);
    }
    {
        RandomGraph theObject;
        eq(5, theObject.probability(50, 10),0.7494276522159893);
    }
    {
        RandomGraph theObject;
        eq(6, theObject.probability(50, 1000),1.0);
    }
}
// END CUT HERE
